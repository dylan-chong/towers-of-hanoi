# Report #

## What was done ##

Note: a '[x]' represents a completed task it is the markdown symbol for a
ticked tickbox

Minimum out of 30:
 - [x] (15) Creates the match table for the input pattern.
 - [x] (15) Performs correct KMP substring search with the pattern and text.

Core out of 30 (up to 70):
 - [x] (5) Finds the frequency histogram for an input text.
 - [ ] (10) Creates the coding tree for an input text.
 - [ ] (5) Correctly encodes input.
 - [ ] (5) Correctly decodes input.
 - [ ] (5) Answers questions 1 and 2.

Completion out of 30 (up to 90):
 - [ ] (10) Correctly performs Lempel Ziv compression.
 - [ ] (10) Correctly performs Lempel Ziv decompression.
 - [ ] (10) Answers questions 3 and 4.

Challenge out of 10 (up to 100, 5 spare marks):
 - [ ] (10) Implement Boyer-Moore string search OR a more complex coding algorithm,
        for example:
         - Adaptive Huffman coding
         - Arithmetic coding
 - [ ] (5) Find a algorithm for question 5 so that |Z| << 2*(|X| + |Y|).

# Questions #

## Q1 ##

I wrote some benchmarks for comparison between BruteForce and KMP algorithms
See report-string-search-benchmark.png for comparisons - look at the 'median
duration field'.

KMP was mostly faster than brute force, which makes sense because the brute
force rechecks characters multiple times, especially if there are lots of
occurrences of the pattern's prefix.

The brute force search was faster for the 3rd test in the png file, where the
match was at the start, and the pattern was long. There is some overhead in
making the table, especially for a long pattern, so KMP would lag behind
during the checking of the pattern. This is the best case for the brute force
because no characters will have to be checked twice
